package org.javacs;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.*;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

class InferConfig {
    private static final Logger LOG = Logger.getLogger("main");

    /** Root of the workspace that is currently open in VSCode */
    private final Path workspaceRoot;
    /** Location of the maven repository, usually ~/.m2 */
    private final Path mavenHome;

    InferConfig(Path workspaceRoot, Path mavenHome) {
        this.workspaceRoot = workspaceRoot;
        this.mavenHome = mavenHome;
    }

    InferConfig(Path workspaceRoot) {
        this(workspaceRoot, defaultMavenHome());
    }

    private static Path defaultMavenHome() {
        return Paths.get(System.getProperty("user.home")).resolve(".m2");
    }

    Set<Path> classPath() {
        Set<Path> result = new HashSet<>();
        result.addAll(buildClassPath());
        result.addAll(workspaceClassPath());
        return result;
    }

    /** Find .jar files for external dependencies, for examples maven dependencies in ~/.m2 or jars in bazel-genfiles */
    Set<Path> buildClassPath() {
        Set<Path> result = new HashSet<>();

        // Maven
        Collection<Artifact> as = mvnDependencies();
        if (!as.isEmpty()) {
            LOG.info("Looking for artifacts:");
            for (Artifact a : as) {
                LOG.info("  " + a);
            }
        }
        for (Artifact a : as) {
            Optional<Path> found = findMavenJar(a, false);
            if (found.isPresent()) result.add(found.get());
            else LOG.warning(String.format("Couldn't find jar for %s in %s", a, mavenHome));
        }

        // Bazel
        if (Files.exists(workspaceRoot.resolve("WORKSPACE"))) {
            Path bazelGenFiles = workspaceRoot.resolve("bazel-genfiles");

            if (Files.exists(bazelGenFiles) && Files.isSymbolicLink(bazelGenFiles)) {
                Set<Path> jars = bazelJars(bazelGenFiles);
                LOG.info(String.format("Adding bazel dependencies in %s:", bazelGenFiles));
                for (Path j : jars) {
                    LOG.info("  " + bazelGenFiles.toAbsolutePath().relativize(j));
                }
                result.addAll(jars);
            }
        }

        return result;
    }

    /**
     * Find directories that contain java .class files in the workspace, for example files generated by maven in
     * target/classes
     */
    Set<Path> workspaceClassPath() {
        // Bazel
        if (Files.exists(workspaceRoot.resolve("WORKSPACE"))) {
            Path bazelBin = workspaceRoot.resolve("bazel-bin");

            if (Files.exists(bazelBin) && Files.isSymbolicLink(bazelBin)) {
                return bazelOutputDirectories(bazelBin);
            }
        }

        // Maven
        try {
            return Files.walk(workspaceRoot).flatMap(this::outputDirectory).collect(Collectors.toSet());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /** Recognize build root files like pom.xml and return compiler output directories */
    private Stream<Path> outputDirectory(Path file) {
        if (file.getFileName().toString().equals("pom.xml")) {
            Path target = file.resolveSibling("target");

            if (Files.exists(target) && Files.isDirectory(target)) {
                return Stream.of(target.resolve("classes"), target.resolve("test-classes"));
            }
        }

        // TODO gradle

        return Stream.empty();
    }

    /**
     * Search bazel-bin for per-module output directories matching the pattern:
     *
     * <p>bazel-bin/path/to/module/_javac/rule/lib*_classes
     */
    private Set<Path> bazelOutputDirectories(Path bazelBin) {
        try {
            Path target = Files.readSymbolicLink(bazelBin);
            PathMatcher match = FileSystems.getDefault().getPathMatcher("glob:**/_javac/*/lib*_classes");

            return Files.walk(target).filter(match::matches).filter(Files::isDirectory).collect(Collectors.toSet());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /** Search bazel-genfiles for jars */
    private Set<Path> bazelJars(Path bazelGenFiles) {
        try {
            Path target = Files.readSymbolicLink(bazelGenFiles);

            return Files.walk(target)
                    .filter(file -> file.getFileName().toString().endsWith(".jar"))
                    .collect(Collectors.toSet());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /** Find source .jar files for `externalDependencies` in local maven / gradle repository. */
    Set<Path> buildDocPath() {
        Set<Path> result = new HashSet<>();
        // Maven
        for (Artifact a : mvnDependencies()) {
            findMavenJar(a, true).ifPresent(result::add);
        }
        // TODO Bazel
        return result;
    }

    Optional<Path> findMavenJar(Artifact artifact, boolean source) {
        Path jar =
                mavenHome
                        .resolve("repository")
                        .resolve(artifact.groupId.replace('.', File.separatorChar))
                        .resolve(artifact.artifactId)
                        .resolve(artifact.version)
                        .resolve(fileName(artifact, source));

        if (Files.exists(jar)) return Optional.of(jar);
        else return Optional.empty();
    }

    private String fileName(Artifact artifact, boolean source) {
        return artifact.artifactId + '-' + artifact.version + (source ? "-sources" : "") + ".jar";
    }

    static List<Artifact> dependencyList(Path pomXml) {
        Objects.requireNonNull(pomXml, "pom.xml path is null");

        try {
            // Tell maven to output deps to a temporary file
            Path outputFile = Files.createTempFile("deps", ".txt");

            String cmd =
                    String.format(
                            "%s dependency:list -DincludeScope=test -DoutputFile=%s", getMvnCommand(), outputFile);
            File workingDirectory = pomXml.toAbsolutePath().getParent().toFile();
            int result = Runtime.getRuntime().exec(cmd, null, workingDirectory).waitFor();

            if (result != 0) throw new RuntimeException("`" + cmd + "` returned " + result);

            return readDependencyList(outputFile);
        } catch (InterruptedException | IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static List<Artifact> readDependencyList(Path outputFile) {
        Pattern artifact = Pattern.compile(".*:.*:.*:.*:.*");

        try (InputStream in = Files.newInputStream(outputFile)) {
            return new BufferedReader(new InputStreamReader(in))
                    .lines()
                    .map(String::trim)
                    .filter(line -> artifact.matcher(line).matches())
                    .map(Artifact::parse)
                    .collect(Collectors.toList());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /** Get external dependencies from this.externalDependencies if available, or try to infer them. */
    private Collection<Artifact> mvnDependencies() {
        Path pomXml = workspaceRoot.resolve("pom.xml");

        if (Files.exists(pomXml)) return dependencyList(pomXml);

        return Collections.emptyList();
    }

    static String getMvnCommand() {
        String mvnCommand = "mvn";
        if (File.separatorChar == '\\') {
            mvnCommand = findExecutableOnPath("mvn.cmd");
            if (mvnCommand == null) {
                mvnCommand = findExecutableOnPath("mvn.bat");
            }
        }
        return mvnCommand;
    }

    private static String findExecutableOnPath(String name) {
        for (String dirname : System.getenv("PATH").split(File.pathSeparator)) {
            File file = new File(dirname, name);
            if (file.isFile() && file.canExecute()) {
                return file.getAbsolutePath();
            }
        }
        return null;
    }
}
